# This class represents an entry in the look-up table used to reverse translate
# a given log message. Here, we take as input a parsed-out POT file entry 
# (generated by POParser) and from there, we convert message strings of the form
# p1 m1 p2 m2 ... where p1 = parameter 1, m1 = message 1 to regexes of the form
# (.*) m1 (.*) m2 ... and map these regexes to the corresponding msgid (or msgid_plural).
class POEntry
  # TODO: Maybe refactor these? Bit hard to read
  PARAM_SUB_RE = /(?:\A|([^\\]))\\\{\d+\\\}/
  PARAM_RE = /(?:\A|([^\\]))\{(\d+)\}/

  def initialize(pot_entry)
    msgid_part, msgstr_part = pot_entry
    translation = msgid_part["msgid#{"_plural" if msgid_part.size > 1}"]
    @translations = msgstr_part.values.map do |value| 
      key_regex = to_regex(value)
      param_ordering = value.scan(PARAM_RE).map { |e| e[1].to_i }
      [key_regex, [translation, param_ordering]]
    end.to_h
  end
  
  def to_regex(msgstr) 
    Regexp.new(Regexp.escape(msgstr).gsub(PARAM_SUB_RE,'\1(?m-ix:(.*))'))
  end

  # This method extracts the parameters (in numeric order) of "msg"
  # given the matching_re. It returns an array of three things:
  #    [pre, params, post]
  # where pre is the part of the message before the match, params 
  # are the messages' parameters, and post is the part of the message
  # after the match.
  def extract_params(msg, match_re)
    match_obj = match_re.match(msg)
    params = @translations[match_re][1].zip(match_obj[1..-1]).sort.map { |e| e[1] }
    [match_obj.pre_match, params, match_obj.post_match]
  end

  # This method does the reverse translation. Here we find the first matching
  # msgstr in our translation map, extract out the parameters, translate it to
  # its original form, and then put the parameters back in. Note that only part
  # of the message might be translated.
  def reverse_translate(msg)
    match_re = @translations.keys.find { |k| msg =~ k }
    return msg if match_re == nil 
    pre, params, post = extract_params(msg, match_re) 
    final_in, final_out = params.inject([@translations[match_re][0], ""]) do |accum, param|
      input, output = accum
      param_match = PARAM_RE.match(input)
      rem_input = param_match.post_match
      new_output = output + (param_match.pre_match + param_match[1].to_s + param)
      [rem_input, new_output]
    end
    pre + final_out + final_in + post
  end

  private #:to_regex#, :extract_params
end
