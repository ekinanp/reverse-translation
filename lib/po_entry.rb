# This class represents an entry in the look-up table used to reverse translate
# a given log message. Here, we take as input a parsed-out POT file entry 
# (generated by POParser) and from there, we convert message strings of the form
# p1 m1 p2 m2 ... where p1 = parameter 1, m1 = message 1 to regexes of the form
# (.*) m1 (.*) m2 ... and map these regexes to the corresponding msgid (or msgid_plural).
class POEntry
  # TODO: Maybe refactor these? Bit hard to read
  PARAM_SUB_RE = /(?:\A|([^\\]))\\\{\d+\\\}/
  PARAM_RE = /(?:\A|([^\\]))\{\d+\}/

  def initialize(pot_entry)
    msgid_part, msgstr_part = pot_entry
    translation = msgid_part["msgid#{"_plural" if msgid_part.size > 1}"]
    @translations = msgstr_part.values.map do |value| 
      key_regex = to_regex(value)
      [key_regex, translation]
    end.to_h
  end
  
  def to_regex(msgstr) 
    Regexp.new(Regexp.escape(msgstr).gsub(PARAM_SUB_RE,'\1(?m-ix:(.*))'))
  end

  # This method does the reverse translation. Here we find the first matching
  # msgstr in our translation map, extract out the parameters, translate it to
  # its original form, and then put the parameters back in. Note that only part
  # of the message might be translated.
  def reverse_translate(msg)
    match_re = @translations.keys.find { |k| msg =~ k }
    return msg if match_re == nil 
    match_obj = match_re.match(msg) 
    final_in, final_out = match_obj[1..-1].inject([@translations[match_re], ""]) do |accum, param|
      input, output = accum
      param_match = PARAM_RE.match(input)
      rem_input = param_match.post_match
      new_output = output + (param_match.pre_match + param_match[1].to_s + param)
      [rem_input, new_output]
    end
    match_obj.pre_match + final_out + final_in + match_obj.post_match
  end
end
